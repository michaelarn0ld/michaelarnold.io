<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/zettel.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="/resources/favicon.ico">
    <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michael Arnold</title>
    <script src="/js/components/Header.js" ></script>
    <script src="/js/components/Footer.js" ></script>
</head>
<body>
    <header-component></header-component>
    <main>
        <div>
            <h1>Concurrent Java: Getting the First Finished Future<span>.</span></h1>
            <p>
              This is a small java program that demonstrates how to return the first completed
              task from a list of concurrently submitted callables. In addition, if the a
              callable happens to throw an exception, we will handle the exception and wait
              until one of our callables successfully returns a good value.
            </p>
        </div>
        <div>
            <div class="subtopic"><h2>Implemented Callable Class</h2></div>
            <pre class="prettyprint">
import java.util.Random;
import java.util.concurrent.Callable;

public class Item implements Callable<Integer> {

    private final long waitTime;

    private final int name;

    public Item(int name) {
        this.name = name;
        // Each of our tasks will have some random wait time before it returns
        // Simulation of network latency...
        waitTime = (long)(new Random().nextDouble() * 10000) + 1000;
    }

    @Override
    public Integer call() throws Exception {
        // Sometimes maybe our thread might have an exception. Let's introduce
        // errors into the mix so we could handle them in the main program
        if (new Random().nextDouble() > 0.5) {
            throw new RuntimeException("foo");
        }
        Thread.sleep(waitTime);
        return name;
    }
}
            </pre>
        </div>
        <div>
            <div class="subtopic"><h2>Main Class</h2></div>
            <pre class="prettyprint">
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class App {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        List<Integer> names = new ArrayList<>();

        // We are going to submit 100 tasks concurrently
        for (int i = 0; i < 100; ++i) {
            names.add(i);
        }

        ExecutorService threadPool = Executors.newCachedThreadPool();
        CompletionService<Integer> ecs = new ExecutorCompletionService<>(threadPool);

        // submit each callable on a thread
        names.stream().map(Item::new).forEach(ecs::submit);
        Integer name = null;

        for (int i = 0; i < 1; ++i) {
            try {
               // Futures are returned in completion order
               Future<Integer> take = ecs.take();
               name = take.get();
            } catch (ExecutionException e) {
                i--;
            }
        }
        System.out.println(name);

        // Close the execution service
        threadPool.shutdownNow();
    }

}

            </pre>
        </div>
        <div>
            <div class="subtopic"><h2>Tags</h2></div>
            <p>#concurrent #java</p>
        </div>
    </main>
    <footer-component></footer-component>
    <script type="module" src="/js/main.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</body>
